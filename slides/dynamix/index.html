<!doctype html>
<html lang="bg">

<head>
    <meta charset="utf-8">

    <title>DynaMix: A new take on polymorphism in C++</title>

    <meta name="description" content="Slides for a talk about DynaMix">
    <meta name="author" content="Borislav Stanimirov">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="/third_party/reveal/css/reveal.min.css">
    <link rel="stylesheet" href="/third_party/reveal/css/theme/default.css" id="theme">

    <!-- The default heading font doesn't work well with Cyrillic. Change it here -->
    <link rel="stylesheet" href="custom.css">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="/third_party/highlight/css/default.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
    document.write( '<link rel="stylesheet" href="/third_party/reveal/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="/third_party/reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

    <div class="reveal">
        <div class="slides">

            <section>
                <h1>DynaMix</h1>
                <h3>A New Take on Polymorphism in C++</h3>
                <p>
                    by <a href="http://ibob.github.io">Borislav Stanimirov</a>
                </p>
            </section>

            <section class="slide">
                <h3>About</h3>
                <ul>
                    <li>Hi. I'm Borislav.</li>
                    <li><span class="fancy">DynaMix</span> is a C++ library</li>
                    <ul>
                        <li><a href="https://github.com/iboB/dynamix">github.com/iboB/dynamix</a></li>
                    </ul>
                    <li>History</li>
                    <ul>
                        <li>2007: Interface. Zahary Karadjov</li>
                        <li>2013: Rebirth as <span class="fancy">Boost.Mixin</span>. Me</li>
                        <li>2016: Bye, Boost. Hello, <span class="fancy">DynaMix</span></li>
                    </ul>
                    <li>Spread <em>(to my knowledge)</em></li>
                    <ul>
                        <li>One PC MMORPG</li>
                        <li>One released mobile game</li>
                        <li>Two mobile games in development</li>
                    </ul>
                </ul>
            </section>

            <section class="slide">
                <h3>About 2.0</h3>
                <ul>
                    <li>What will be in this talk?</li>
                    <ul>
                        <li>Introducing the <span class="fancy">DynaMix</span> library</li>
                        <li>We will focus on the <span class="fancy">"what"</span> and the <span class="fancy">"why"</span></li>
                        <li>We will hardly even mention the "how"</li>
                    </ul>
                    <li>So, what does this library do?</li>
                    <ul>
                        <li>A means to create a project's <span class="fancy">architecture</span> rather than achieve its purpose</li>
                        <li>Management of <span class="fancy">complex objects</span> in potentially <span class="fancy">multiple subsystems</span></li>
                        <li>Enforces OOP practices like <span class="fancy">composition over inheritance</span>, <span class="fancy">loose coupling</span>, and <span class="fancy">separation of interface and implementation</span></li>
                    </ul>
                </ul>
            </section>

            <section class="slide">
                <h3>The Gist</h3>
                <ul>
                    <li>Building blocks</li>
                    <ul>
                        <li><code class="inline">dynamix::object</code> - just an empty object</li>
                        <li><span class="fancy">Messages</span> - function-like pieces of interface, that an object might implement</li>
                        <li><span class="fancy">Mixins</span> - classes that you've written which actually implement messages</li>
                    </ul>
                    <li>Usage</li>
                    <ul>
                        <li><span class="fancy">Mutation</span> - the process of adding and removing mixins from objects</li>
                        <li><span class="fancy">Calling messages</span> - like calling methods, this is where the actual business logic lies</li>
                    </ul>
                    <li class="evil">I know what a mixin is and it's not this</li>
                    <ul>
                        <li>DynaMix = <span class="fancy">dynamic mixins</span></li>
                    </ul>
                </ul>
            </section>

            <section>
                <h2>Why don't we see some code?</h2>
            </section>

            <section>
<pre><code class="cpp hljs">
class wood_frame
{
public:
    strength get_strength() const {
        return strength(83);
    }
    // other wood-frame-y stuff
};

class titanium_frame
{
public:
    strength get_strength() const {
        return strength(9001);
    }
    // other titanium-frame-y stuff
};

</code></pre>
            </section>

            <section>
<pre><code class="cpp hljs">
class has_drawers
{
public:
    void open(int element) {
        _drawers[element].roll_out();
    }
    // ...
};

class has_doors
{
public:
    void open(int element) {
        _doors[element].open();
    }
    // ...
};

</code></pre>
            </section>

            <section>
<pre><code class="cpp hljs">
// ...after some library-specific code in which we "tell"
// it what mixins and messages there are out there

dynamix::object o;
mutate(o) // composition
    .add&lt;wood_frame&gt;()
    .add&lt;has_doors&gt;();

// message calls
::get_strength(o); // -> strength 83
::open(o, 1); // -> right door opens

mutate(o) // mutation
    .remove&lt;wood_frame&gt;()
    .add&lt;titanium_frame&gt;();

::get_strength(o); // -> strength 9001

</code></pre>
            </section>

            <section>
                <h2>An Actual Basic Example</h2>
                <img src="basic_example.png" />
            </section>

            <section>
                <h2>But why?</h2>
            </section>

            <section class="slide">
                <h3>OOP and Polymorphism</h3>
                <ul>
                    <li>OOP has come to imply dynamic polymorphism</li>
                    <ul>
                        <li>Dynamic polymorphism is when the compiler can see a function call but <span class="fancy">can't know</span> which actual piece of code will be executed next</li>
                        <li>It's in the category of things which are <span class="fancy">slower</span> and <span class="fancy">can't have good compilation errors</span></li>
                        <li>Totally anti modern C++</li>
                    </ul>
                    <li>OOP has been critized a lot</li>
                    <li>C++ is, among other things, an <span class="fancy">OOP language</span></li>
                    <li>Out of the box in an OOP context C++ only gives us <span class="fancy">virtual functions</span> for polymorphism</li>
                </ul>
            </section>

            <section class="slide">
                <h3>An Example Problem</h3>
                <br/>
                <ul>
                    <li>Suppose we want to have an object which is:</li>
                    <ul>
                        <li>A flying creature</li>
                        <li>A two-legged creature</li>
                        <li>Is controlled by a hostile AI</li>
                        <li>Has an associated animated model</li>
                        <li>Has DirectX rendering code</li>
                    </ul>
                </ul>
            </section>

            <section>
                <img class="diagram" src="dragon.png" />
            </section>

            <section>
            <p class="evil">That's easy</p>
<pre><code class="cpp hljs">
class dragon
{
public:
    void fly();
    void walk_on_two_legs();
    void ai_take_the_wheel();
    const model& get_model() const;
    void render_with_directx() const;
// ...
}
</code></pre>
            </section>

            <section class="slide">
                <h3>Implied Conditions</h3>
                <br/>
                <ul>
                    <li>We will have other objects in our game</li>
                    <li>Different subsystems of the game care about different aspects of those objects</li>
                    <li>Different parts of the object may rely on others to work</li>
                </ul>
                <br/>
                <br/>
                <p style="text-align:center">What if we also have a horse or a human character?</p>
            </section>

            <section>
                <img class="diagram" src="inheritance.png" />
            </section>

            <section>
            <p class="evil">Still easy</p>
<pre><code class="cpp hljs">
class dragon : public flying_creature,
    public two_legged_creature, public monster_ai,
    public animated_model, public directx_rendering
{};

class horse : public walking_creature,
    public four_legged_creature, public neutral_ai,
    public animated_model, public direcx_rendering
{};

// ... you get the point
</code></pre>
            </section>

            <section>
                <p>That, in a way, is even worse, because <code class="inline">flying_creature</code> has no way ot telling <code class="inline">animated_model</code> which animation to play.</p>
            </section>

            <section>
            <p class="evil">OK. This time using <span class="fancy">real</span> mixins</p>
<pre><code class="cpp hljs">
template &lt;typename object_type&gt;
class flying_creature
{
public:
    void move()
    {
        flap_wings();
        static_cast&lt;object_type*&gt;(this)
            ->set_animation("flying");
    }
// ...
};

class dragon : public flying_creature&lt;dragon&gt;,
    public two_legged_creature&lt;dragon&gt;,
    public monster_ai&lt;dragon&gt;,
    public animated_model&lt;dragon&gt;,
    public directx_rendering&lt;dragon&gt;
{};

</code></pre>
            </section>

            <section class="slide">
                <br/>
                <br/>
                <ul>
                    <li><span class="fancy">ALL</span> of my code is in headers</li>
                    <li>How can I have an array of objects?</li>
                </ul>
                <br/>
                <br/>
<pre><code class="cpp hljs" data-trim>
template &lt;typename object_type&gt;
class flying_creature : public virtual game_object
{ /* ... */ };

std::vector&lt;game_object*&gt; objects;
</code></pre>
                <br/>
                <p>This is identical to <code class="inline">vector&lt;void*&gt;</code>.<br/>I have no way of using the objects in this array.</li>
                </ul>
            </section>

            <section>
            <p class="evil">Fine. I'm rolling-up my sleeves</p>
<pre><code class="cpp hljs">
class flying_creature : public virtual game_object
{
public:
    virtual void fly() override
    {
        this->flap_wings();
        this->set_animation("flying");
    }
// ...
};

class dragon : public flying_creature,
    public two_legged_creature, public monster_ai,
    public animated_model, public directx_rendering
{
};

</code></pre>
            </section>

            <section class="slide">
            <br/>
            <p>So, all, <span class="fancy">ALL</span> possible methods will exist as pure virtual in <code class="inline">game_object</code></p>
            <p>Also, walking creature cannot fly. You can never instantiate <code class="inline">dragon</code> since it's abstract.</p>
            <br/>
            <br/>
            <p class="evil">Having separate methods for flying and walking was a bad idea, anyway. There should be a single method: <code class="inline">move</code>. In fact how about this:</p>
            </section>

            <section>
<pre><code class="cpp hljs">
class game_object
{
    virtual void move() = 0; // flying, walking, vehicles
    // enemy/neutral ai, keyboard control
    virtual void decide_action() = 0;
    //...
};

class dragon : public flying_creature,
    public two_legged_creature, public monster_ai,
    public animated_model, public directx_rendering
{
    // there still might be invalid actions for the object
    // list them here
    virtual void use(item*) override {
        throw bad_call();
    }
};

</code></pre>
            </section>

            <section class="slide">
            <p>This will work.</p>
            <p class="evil">Aww, yiss!</p>
            <p>But...</p>
            <br/>
            <ul>
                <li>It's impractical</li>
                <li>Every new type of object, needs to be explicity added to the code</li>
                <li>Combinatorial explosion of types</li>
                <li><code class="inline">game_object</code> is a coupling focal point</li>
                <li>As a result no software is written like this (except probably some beginner projects)</li>
            </ul>
            </section>

            <section class="slide">
                <h3>An Example Problem Cont.</h3>
                <br/>
                <ul>
                    <li>Suppose that we also want</li>
                    <ul>
                        <li>To sometimes manually control the dragon</li>
                        <li>To cut the wings off of the dragon and have a plain (well two-legged) lizzard</li>
                        <li>To optionally have add fire-breathing powers to our dragon</li>
                        <li>To be able to choose the rendering API, say to switch to DirectX</li>
                    </ul>
                </ul>
                <br/>
                <br/>
                <p class="evil">I could add such if-checks to all my methods, but I suppose you won't like this</p>
            </section>

            <section>
            <p class="evil">Object</p>
<pre><code class="cpp hljs">
class game_object
{
    control* m_control;
    physical_data* m_physical_data;
    rendering* m_rendering;
    mobility* m_mobility;
    ...
};
// compose
game_entity dragon;
dragon.set_control(new monster_ai);
dragon.set_physical_data(new animated_model("dragon.x"));
dragon.set_mobility(new flyer);
...
// modify
dragon.set_control(new player_control);

</code></pre>
            </section>

            <section>
            <p class="evil">Component</p>
<pre><code class="cpp hljs">
class component
{
    game_object* self;
};

class monster_ai
    : public control, public component
{
    virtual void decide_action() override
    {
        ...
        self->get_mobility()->move_to(good_guy);
    }
};

</code></pre>
            </section>

            <section class="slide">
            <p>This is, actually, a pretty decent solution.</p>
            <ul>
                <li>This is the <span class="fancy">interface to component</span> pattern</li>
                <li>There are <span class="fancy">games</span> and <span class="fancy">CAD systems</span> which use it</li>
                <li>In fact (although not immediately  obvious), using this as a base, you can recreate almost all features of DynaMix (in a concrete and <span class="fancy">unreusable</span> way)</li>
            </ul>
            <p>But...</p>
            <ul>
                <li>Every new type of interface needs to be explicitly added to the <span class="fancy">huge</span> object class</li>
                <li></li>
            </ul>
            </section>

            <section>
                <h1>End</h1>
                <h2>Questions?</h2>
                <br/>
                <p>Borislav Stanimirov / <a href="http://ibob.github.io">ibob.github.io</a></p>
                <p>
                    <br />
                    <small>
                    Link to these slides: <a href="http://ibob.github.io/slides/dynamix/">http://ibob.github.io/slides/dynamix/</a>
                    </small>
                    <br />
                    <small>
                    Slides license <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons By 3.0</a><br /><a rel="license" href="http://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/88x31.png" /></a>
                    </small>
                </p>
            </section>

        </div>
    </div>

    <script src="/third_party/reveal/lib/js/head.min.js"></script>
    <script src="/third_party/reveal/js/reveal.min.js"></script>

    <script>
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            theme: 'solarized', // available themes are in /css/theme
            transition: 'none', // default/cube/page/concave/zoom/linear/fade/none

            // Optional libraries used to extend on reveal.js
            dependencies: [
                { src: '/third_party/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                //{ src: '/third_party/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                //{ src: '/third_party/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: '/third_party/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                //{ src: '/third_party/reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                //{ src: '/third_party/reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
            ]
        });

    </script>

</body>
</html>
