<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>No Touchy! A Case Study of Software Architecture with Immutable Objects</title>

  <meta name="description" content="Slides for a software architecture talk about immutable objects in C++">
  <meta name="author" content="Borislav Stanimirov">

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="../lib/reveal.js-3.8.0/css/reveal.min.css" />
  <link rel="stylesheet" href="../lib/reveal.js-3.8.0/css/theme/simple.min.css" id="theme" />
  <link rel="stylesheet" href="../lib/slides.css" />

  <!-- For syntax highlighting -->
  <link rel="stylesheet" href="/third_party/highlight-new/styles/github-gist.css">

  <!-- Slides-specific styles -->
  <link rel="stylesheet" href="custom.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ?
      'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.8.0/css/print/pdf.min.css' :
      'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.8.0/css/print/paper.min.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>

  <!--[if lt IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.8.0/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>

<body>

  <div class="reveal">
    <div class="slides">
      <section class="title">
        <h1>No Touchy!</h1>
        <h2>Software Architecture with Immutable Objects</h2>
        <h3>A Case Study</h3>
        <br/>
        <p>
          <a href="http://ibob.github.io">Borislav Stanimirov</a> / <a href="https://twitter.com/stanimirovb">@stanimirovb</a>
        </p>
        <p>CppCon 2020</p>
      </section>

      <section class="slide">
        <h3>Hello, World</h3>
        <br/>
        <pre><code class="cpp hljs" data-noescape>
  #include &lt;iostream&gt;

  int main()
  {
      std::cout &lt;&lt; "Hi, I'm Borislav!\n";
      std::cout &lt;&lt; "These slides are here: <span class="fragment hl-code">is.gd/immutable</span>\n";
      return 0;
  }
        </code></pre>
      </section>

      <section class="slide">
        <h3>Borislav Stanimirov</h3>
        <br/>
        <ul>
          <li>Mostly a <span class="fancy">C++</span> programmer</li>
          <li>2006-2018 a <span class="fancy">game</span> programmer</li>
          <li>Since 2019 a <span class="fancy">medical software</span> programmer</li>
          <li><span class="fancy">Open-source</span> programmer</li>
          <li><a href="https://github.com/iboB">github.com/iboB</a></li>
        </ul>
      </section>

      <section>
        <img class="diagram" src="ViewRay_Logo.png"/>
        <p></p>
        <h3>ViewRay's approach to treating cancer</h3>
        <p><em>5 min demo of cancer treatment workflow</em></p>
      </section>

      <section class="slide">
        <h3>What did you just see?</h3>
        <br/>
        <ul>
          <li>Software started <span class="fancy">from scratch</span> in Feb 2019</li>
          <li>Aims to replace the existing software</li>
          <li>Browser GUI</li>
          <li><span class="fancy">C++17</span> backend</li>
        </ul>
      </section>

      <section class="slide">
        <h3>Birds Eye View</h3>
        <ul>
          <li>A browser client</li>
          <li>...connecting to an <span class="fancy">application server</span></li>
          <li>...which has multiple services and workers</li>
          <ul>
            <li><span class="fancy">Service</span>: always alive. Has sessions</li>
            <ul>
              <li>Treatment service</li>
              <li>MRI service</li>
              <li>...</li>
            </ul>
            <li><span class="fancy">Worker</span>: short life. Calculate something and die</li>
            <ul>
              <li>Identify bladder</li>
              <li>Calculate dose</li>
              <li>...</li>
            </ul>
          </ul>
        </ul>
      </section>

      <section>
        <h3>Going Deeper</h3>
      </section>

      <section class="slide">
        <h3>UI Service</h3>
        <br/>
        <ul>
          <li>Has sessions for clients</li>
          <li>Can build type-erased UI objects from the app state</li>
          <li>WS Server - a layer for browsers. Reads and writes JSON</li>
          <li>Theoretically we can have many other layers (say Qt)</li>
        </ul>
      </section>

      <section class="slide">
        <h3>Treatment Service</h3>
        <br/>
        <p>Creates a Treatment Session</p>
        <ul>
          <li>Has a state which represents a treatment in progress</li>
          <li>Fetches imaging info from the MRI Service</li>
          <li>Issues start/stop to the Radiotherapy Service</li>
          <li>Gathers information about the delivered dose</li>
          <li>At the end saves treatment data to the database</li>
        </ul>
      </section>

      <section>
        <img class="diagram" src="deeper.jpg"/>
      </section>

      <section>
        <h3>Objects</h3>
      </section>

      <section class="slide">
        <h3>Object</h3>
        <br/>
        <pre><code class="cpp hljs" data-noescape>
  class Object {
  public:
    Data& data() { return m_data; }
    const Data& data() { return m_data; }
  private:
    Data m_data;
  };
        </code></pre>
      </section>

      <section>
        <p>Multiple threads. Races</p>
      </section>

      <section class="slide">
        <h3><code>std::mutex</code></h3>
        <pre><code class="cpp hljs" data-noescape>
  class Object {
  public:
    void lock() { m_mutex.lock(); }
    void unlock() { m_mutex.unlock(); }
  private:
    std::mutex m_mutex;
    Data m_data;
  };
        </code></pre>
        <p class="pinner fragment"><span class="fancy">Bad idea&trade;</span> Readers will have to wait on each other</p>
      </section>

      <section class="slide">
        <h3><code>std::shared_mutex</code></h3>
        <pre><code class="cpp hljs" data-noescape>
  class Object {
  public:
    void readLock() { m_mutex.lock_shared(); }
    void readUnlock() { m_mutex.unlock_shared(); }

    void writeLock()  { m_mutex.lock(); }
    void writeUnlock()  { m_mutex.unlock(); }
  private:
    std::shared_mutex m_mutex;
    Data m_data;
  };
        </code></pre>
        <p class="pinner fragment">Let's try to work with this</p>
      </section>

      <section class="slide">
        <h3><code>std::shared_mutex</code></h3>
        <pre><code class="cpp hljs" data-noescape>
  class Object {
  public:
    void readLock() <span class="hl-code-i">const</span> { m_mutex.lock_shared(); }
    void readUnlock() <span class="hl-code-i">const</span> { m_mutex.unlock_shared(); }

    void writeLock()  { m_mutex.lock(); }
    void writeUnlock()  { m_mutex.unlock(); }
  private:
    <span class="hl-code-i">mutable</span> std::shared_mutex m_mutex;
    Data m_data;
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3><code>std::shared_mutex</code></h3>
        <pre><code class="cpp hljs" data-noescape>
  class Object {
  <span class="hl-code-i">private:</span>
    void readLock() const { m_mutex.lock_shared(); }
    void readUnlock() const { m_mutex.unlock_shared(); }

    void writeLock()  { m_mutex.lock(); }
    void writeUnlock()  { m_mutex.unlock(); }

    mutable std::shared_mutex m_mutex;
    Data m_data;
<span class="hl-code-i">    friend class ObjectReadLock;
    friend class ObjectWriteLock;</span>
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Object Read Lock</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectReadLock {
  public:
    ObjectReadLock(const Object&amp; obj) : m_object(obj) {
      <span class="hl-code-i">m_object.readLock();</span>
    }
    ~ObjectReadLock() { <span class="hl-code-i">m_object.readUnlock();</span> }

    const Object* operator-&gt;() const { return &amp;m_object; }
    const Object* operator*() const  { return &amp;m_object; }
  private:
    const Object&amp; m_object;
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Object Write Lock</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWriteLock {
  public:
    ObjectWriteLock(Object&amp; obj) : m_object(obj) {
      <span class="hl-code-i">m_object.writeLock();</span>
    }
    ~ObjectWriteLock() { <span class="hl-code-i">m_object.writeUnlock();</span> }

    Object* operator-&gt;() { return &amp;m_object; }
    Object* operator*()  { return &amp;m_object; }
  private:
    Object&amp; m_object;
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Shared Mutex Problems</h3>
        <br/>
        <ul>
          <li class="fragment ss">Writers will have to wait on each other</li>
          <li class="fragment">Writers will have to wait on readers</li>
          <ul class="fragment">
            <li>Our anatomical structures</li>
            <li>Contouring algorithms write</li>
            <li>Dose calculation reads</li>
            <li>UI reads</li>
            <li>Contouring algorithms may also read</li>
          </ul>
        </ul>
      </section>

      <section>
        <img src="cow.png" />
        <p class="fragment">CoW &ndash; Copy on Write</p>
      </section>

      <section class="slide">
        <h3>Classic Swift-style CoW</h3>
        <pre><code class="cpp hljs" data-noescape>
  template &lt;typename T&gt;
  class CoW {
      std::shared_ptr&lt;T&gt; m_data;
  public:
<span class="fragment hl-code">      const T& data() const {
          return *m_data;
      }</span>
      T& mutableData() {
          <span class="fragment hl-code">if (m_data.use_count() &gt; 1)</span>
              <span class="fragment hl-code">m_data = std::make_shared&lt;T&gt;(*m_data);</span>
          return *m_data;
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Object CoW</h3>
        <pre><code class="cpp hljs" data-noescape>

  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
  public:
      const Object&amp; read() const {
          return *m_object;
      }
      Object&amp; write() {
          if (m_object.use_count() &gt; 1)
              m_object = std::make_shared&lt;Object&gt;(*m_object);
          return *m_object;
      }
  };
        </code></pre>
        <p class="pinner fragment">How do we refer to objects?</p>
      </section>

      <section class="slide">
        <h3>Referring to Objects</h3>
        <pre><code class="cpp hljs" data-noescape>
ObjectWrapper myobj;
<span class="fragment hl-code">std::thread gui([]() { guiLoop(myobj); });</span>
<span class="fragment hl-code">myobj.write().changeSomething();</span>

...

void guiLoop(ObjectWrapper obj) {
<span class="fragment hl-code">  while (true) {
    display(obj.read().getSomething());
  }</span>
}
        </code></pre>
      </section>

      <section class="slide">
        <h3>Referring to Objects</h3>
        <pre><code class="cpp hljs" data-noescape>
ObjectWrapper myobj;
std::thread gui([]() { guiLoop(myobj); });
myobj.write().changeSomething(); <span class="hl-code-i">// Uh oh! After this line</span>

...

void guiLoop(ObjectWrapper obj) {
  while (true) {
    display(obj.read().getSomething()); <span class="fragment hl-code-i">// No way to access changed here</span>
  }
}
        </code></pre>
      </section>

      <section class="slide">
        <h3>Object Handle</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
  public:
      const Object&amp; read() const {
          return *m_object;
      }
      Object&amp; write() {
          if (m_object.use_count() &gt; 1)
              m_object = std::make_shared&lt;Object&gt;(*m_object);
          return *m_object;
      }
  };
  <span class="fragment hl-code-i">using ObjectHandle = std::shared_ptr&lt;ObjectWrapper&gt;;</span>
        </code></pre>
      </section>

      <section class="slide">
        <h3>Referring to Objects through Handles</h3>
        <pre><code class="cpp hljs" data-noescape>
<span class="hl-code-i">ObjectHandle</span> myobj;
std::thread gui([]() { guiLoop(myobj); });
myobj<span class="hl-code-i">-&gt;</span>write().changeSomething(); <span class="fragment hl-code-i">// Uh oh! during this line</span>

...

void guiLoop(<span class="hl-code-i">ObjectHandle</span> obj) {
  while (true) {
    display(obj<span class="hl-code-i">-&gt;</span>read().getSomething()); <span class="fragment hl-code-i">// We race on the shared pointer here</span>
  }
}
        </code></pre>
      </section>

      <section class="slide">
        <h3>Object Handle Races</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
  public:
<span class="fragment hl-code">      std::shared_ptr&lt;const Object&gt; read() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }</span>
      Object&amp; write() {
          if (m_object.use_count() &gt; 1) {
<span class="fragment hl-code">              auto newObject = std::make_shared&lt;Object&gt;(*m_object);
              std::atomic_store_explicit(&amp;m_object, newObject,
                  std::memory_order_relaxed);</span>
          }
          return *m_object;
      }
  };
  using ObjectHandle = std::shared_ptr&lt;ObjectWrapper&gt;;
        </code></pre>
      </section>

      <section class="slide">
        <h3>Referring to Objects through Handles</h3>
        <pre><code class="cpp hljs" data-noescape>
ObjectHandle myobj;
std::thread gui([]() { guiLoop(myobj); });
myobj-&gt;write().changeSomething(); <span class="fragment hl-code-i">// Uh oh! during this line</span>

...

void guiLoop(ObjectHandle obj) {
  while (true) {
    display(obj-&gt;read()<span class="hl-code-i">-&gt;</span>getSomething()); <span class="fragment hl-code-i">// We race on object contents in "Something"</span>
  }
}
        </code></pre>
      </section>

      <section class="slide">
        <h3>Always CoW</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      <span class="fragment hl-code">std::shared_ptr&lt;Object&gt; m_writeObject;</span>
  public:
      std::shared_ptr&lt;const Object&gt; read() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
<span class="fragment hl-code">      std::shared_ptr&lt;Object&gt; writeLock() {
          m_writeObject = std::make_shared&lt;Object&gt;(*m_object);
          return m_writeObject;
      }</span>
<span class="fragment hl-code">      void writeUnlock() {
          std::atomic_store_explicit(&amp;m_object, m_writeObject,
              std::memory_order_relaxed);
      }</span>
  };
  using ObjectHandle = std::shared_ptr&lt;ObjectWrapper&gt;;
        </code></pre>
      </section>

      <section class="slide">
        <h3>Bring Back Locks</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectReadLock {
  public:
    ObjectReadLock(const ObjectHandle& handle) : m_object(handle.read()) {}

    const Object* operator-&gt;() const { return m_object.get(); }
    const Object* operator*() const  { return *m_object; }
  private:
    std::shared_ptr&lt;const Object&gt; m_object;
  };
        </code></pre>
        <p class="pinner">...not necessarily needed</p>
      </section>

      <section class="slide">
        <h3>Bring Back Locks</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWriteLock {
  public:
    ObjectWriteLock(const ObjectHandle& handle) : m_handle(handle) {
      m_object = m_handle.writeLock();
    }
    ~ObjectWriteLock() {
      m_handle.writeUnlock();
    }

    Object* operator-&gt;() { return m_object.get(); }
    Object* operator*()  { return *m_object; }
  private:
    ObjectHandle m_handle;
    std::shared_ptr&lt;Object&gt; m_object;
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Referring to Objects through Locks</h3>
        <pre><code class="cpp hljs" data-noescape>
ObjectHandle myobj;
std::thread gui([]() { guiLoop(myobj); });
<span class="fragment hl-code">ObjectWriteLock(myobj)-&gt;changeSomething();</span>

...

void guiLoop(ObjectHandle obj) {
  while (true) {
    display(<span class="fragment hl-code">ObjectReadLock(obj)-&gt;getSomething()</span>);
  }
}
        </code></pre>
        <p class="pinner fragment">This can totally work <span class="fragment">if we <span class="fancy">promise</span> to only <span class="fancy">write from a single thread</span></span></p>
        <p class="pinner fragment">... but what if we want to write from several threads?</p>
      </section>

      <section class="slide">
        <h3>Multiple writers</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject; <span class="hl-code-i">// Make this thread safe?</span>
                                             <span class="fragment hl-code-i">// Where is the *real* data then?</span>
      std::shared_ptr&lt;const Object&gt; read() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; writeLock() {
          m_writeObject = std::make_shared&lt;Object&gt;(*m_object);
          return m_writeObject;
      }
      void writeUnlock() {
          std::atomic_store_explicit(&amp;m_object, m_writeObject,
              std::memory_order_relaxed);
      }
  };
  using ObjectHandle = std::shared_ptr&lt;ObjectWrapper&gt;;
        </code></pre>
      </section>

      <section class="slide">
        <h3>Heavy Artillery</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject;
      <span class="hl-code-i">std::mutex m_accessMutex;</span>
      std::shared_ptr&lt;const Object&gt; read() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; writeLock() {
          <span class="hl-code-i">m_accessMutex.lock();</span>
          m_writeObject = std::make_shared&lt;Object&gt;(*m_object);
          return m_writeObject;
      }
      void writeUnlock() {
          std::atomic_store_explicit(&amp;m_object, m_writeObject,
              std::memory_order_relaxed);
          <span class="hl-code-i">m_accessMutex.unlock();</span>
      }
  };
  using ObjectHandle = std::shared_ptr&lt;ObjectWrapper&gt;;
        </code></pre>
      </section>

      <section>
        <p>And these are immutable objects</p>
      </section>

      <section>
        <h3>Immutable?</h3>
        <p>Think <code class="cinline">std::string_view</code></p>
        <p>You don't change. You replace.</p>
        <p>In this case with a copy.</p>
      </section>

      <section>
        <p>Remember the optional CoW?</p>
        <p>What if we still want that?</p>
      </section>

      <section>
        <section>
          <h3>Addendum A: Optional CoW</h3>
        </section>

      <section class="slide">
        <h3>What if?</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject;
      std::mutex m_accessMutex;
      std::shared_ptr&lt;const Object&gt; read() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; writeLock() {
          m_accessMutex.lock();
<span class="hl-code-i">          m_writeObject = (m_object.use_count() &gt; 1)
              ? std::make_shared&lt;T&gt;(*m_object);
              : m_object;</span> <span class="fragment hl-code-i">// readers suffer from races</span>
          return m_writeObject;
      }
      void writeUnlock() {
      ...
        </code></pre>
      </section>

      <section class="slide">
        <h3>Lock on Read</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject;
      std::mutex m_accessMutex;
      std::shared_ptr&lt;const Object&gt; read() const {
          <span class="hl-code-i">std::lock_guard l(m_accessMutex);</span>
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; writeLock() {
          m_accessMutex.lock();
          m_writeObject = (m_object.use_count() &gt; 1)
              ? std::make_shared&lt;T&gt;(*m_object);
              : m_object;
          return m_writeObject;
      }
      void writeUnlock() {
      ...
        </code></pre>
      </section>

      <section class="slide">
        <h3>Lock on Read</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::mutex m_accessMutex;
      std::shared_ptr&lt;const Object&gt; read() const {
          std::lock_guard l(m_accessMutex);
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; writeLock() {
          m_accessMutex.lock();
<span class="hl-code-i">          if (m_object.use_count() &gt; 1) {
              auto newObject = std::make_shared&lt;Object&gt;(*m_object);
              std::atomic_store_explicit(&amp;m_object, newObject,
                  std::memory_order_relaxed);
          }
          return m_object;</span>
      }
      void writeUnlock() {
          <span class="fragment hl-code">m_accessMutex.unlock();</span>
      }
        </code></pre>
      </section>

      <section class="slide">
        <h3>Are we done?</h3>
        <ul>
          <li class="fragment">While testing we get some suspicious CoWs</li>
          <li class="fragment">Uh-oh! Concurrent writers with no reads CoW??</li>
        </ul>
        <pre class="fragment"><code class="cpp hljs" data-noescape>
  class ObjectWriteLock {
  public:
    ObjectWriteLock(const ObjectHandle& handle) : m_handle(handle) {
      m_object = m_handle.writeLock();
    }
    ~ObjectWriteLock() {
      m_handle.writeUnlock(); <span class="fragment hl-code-i">// we unlock the mutex but retain a ref</span>
    }

    Object* operator-&gt;() { return m_object.get(); }
    Object* operator*()  { return *m_object; }
  private:
    ObjectHandle m_handle;
    std::shared_ptr&lt;Object&gt; m_object;
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Fix A</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWriteLock {
  public:
    ObjectWriteLock(const ObjectHandle& handle) : m_handle(handle) {
      m_object = m_handle.writeLock();
    }
    ~ObjectWriteLock() {
      <span class="hl-code-i">m_object.reset();</span>
      m_handle.writeUnlock();
    }

    Object* operator-&gt;() { return m_object.get(); }
    Object* operator*()  { return *m_object; }
  private:
    ObjectHandle m_handle;
    std::shared_ptr&lt;Object&gt; m_object;
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Fix B</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWriteLock {
  public:
    ObjectWriteLock(const ObjectHandle& handle) : m_handle(handle) {
      m_object = m_handle.writeLock()<span class="hl-code-i">.get()</span>;
    }
    ~ObjectWriteLock() {
      m_handle.writeUnlock();
    }
    // OMG THE PERF GAIN
    Object* operator-&gt;() { return m_object; }
    Object* operator*()  { return *m_object; }
  private:
    ObjectHandle m_handle;
    <span class="hl-code-i">Object* m_object = nullptr;</span>
  };
        </code></pre>
        <p class="pinner fragment">At first we chose this</p>
      </section>

      <section class="slide">
        <h3>We Can't Have Nice Things</h3>
        <br/>
        <ul>
          <li class="fragment">Run this with TSAN</li>
          <li class="fragment">Get a ton of race warnings</li>
          <li class="fragment">Investigate</li>
          <li class="fragment"><code class="cinline">std::shared_ptr::use_count</code> uses a relaxed memory order</li>
        </ul>
      </section>

      <section class="slide">
        <h3>What did TSAN see?</h3>
        <ul>
          <li class="fragment">Thread A is reading from an object</li>
          <li class="fragment">Thread B makes a write lock</li>
          <li class="fragment">What would <code class="cinline">if (m_object.use_count() &gt; 1)</code> do?</li>
          <ul>
            <li class="fragment">If the read finishes around that time, <code>use_count</code> will be 1</li>
            <li class="fragment">But a reorder might happen and we can get 1 there before the reader has finished reading</li>
            <li class="fragment">In such case we won't make a CoW and will instead write to the same object</li>
            <li class="fragment">But <code>~shared_ptr()</code> uses release on the use count, so this can't happen</li>
          </ul>
        </ul>
      </section>

      <section class="slide">
        <h3>The sad Truth</h3>
        <br/>
        <ul>
          <li class="fragment">After mucho mucho investigation</li>
          <li class="fragment">This sadly is a false positive</li>
          <li class="fragment">TSAN is trying to be smart. It reads C++ code and not just assembly.</li>
          <li class="fragment">It "knows" of the release-acquire relatioship and assumes relaxed loads are not part of it</li>
          <li class="fragment">There are no actual races!</li>
        </ul>
      </section>

      <section>
        <p>:(</p>
      </section>

      <section>
        <p>What can we do?</p>
      </section>

      <section class="slide">
        <h3>Options</h3>
        <br/>
        <ul>
          <li class="fragment">Live with it? <span class="fragment">Bad idea&trade;.</span> <span class="fancy fragment">TSAN is too awesome to abandon</span></li>
          <li class="fragment">Rewrite <code>std::shared_ptr</code> with a method <code class="cinline">use_count_acquire</code></li>
          <ul class="fragment">
            <li>Not as bad as it sounds. There are benefits</li>
          </ul>
          <li class="fragment">Reimplement ref counting for objects</li>
        </ul>
      </section>

      <section>
        <pre><code class="cpp hljs" data-noescape>
  class Object {
  public:
      void Object::incReadLockCounter() const {
          m_numActiveReadLocks.fetch_add(1, std::memory_order_relaxed);
      }
      void Object::decReadLockCounter() const {
          m_numActiveReadLocks.fetch_sub(1, <span class="hl-code-i">std::memory_order_release</span>);
      }
      bool Object::hasReadLocks() const {
          return m_numActiveReadLocks.load(<span class="hl-code-i">std::memory_order_acquire</span>) &gt; 0;
      }
  private:
      mutable std::atomic_int32_t m_numActiveReadLocks = {};
  };
        </code></pre>
        <pre><code class="cpp hljs" data-noescape>
      std::shared_ptr&lt;Object&gt; ObjectWrapper::writeLock() {
          m_accessMutex.lock();
          if (<span class="hl-code-i">m_object-&gt;hasReadLocks()</span>) {
              ...
        </code></pre>
      </section>

      <section class="slide">
        <h3>Options</h3>
        <br/>
        <ul>
          <li>Live with it? Bad idea&trade;. <span class="fancy">TSAN is too awesome to abandon</span></li>
          <li>Rewrite <code>std::shared_ptr</code> with a method <code class="cinline">use_count_acquire</code></li>
          <ul>
            <li>Not as bad as it sounds. There are benefits</li>
          </ul>
          <li>Reimplement ref counting for objects</li>
          <li class="fragment">Or... <span class="fancy">hack around it</span></li>
        </ul>
      </section>

      <section class="slide">
        <h3>Our Optimized Write Lock</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWriteLock {
  public:
    ObjectWriteLock(const ObjectHandle& handle) : m_handle(handle) {
      m_object = m_handle.writeLock().get();
    }
    ~ObjectWriteLock() {
      m_handle.writeUnlock();
    }
    // OMG THE PERF GAIN
    Object* operator-&gt;() { return m_object; }
    Object* operator*()  { return *m_object; }
  private:
    ObjectHandle m_handle;
    Object* m_object = nullptr;
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Our Deoptimized Write Lock</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWriteLock {
  public:
    ObjectWriteLock(const ObjectHandle& handle) : m_handle(handle) {
      m_object = m_handle.writeLock();
    }
    ~ObjectWriteLock() {
      <span class="hl-code-i">m_object.reset();</span>
      m_handle.writeUnlock();
    }
    // OMG THE PERF LOSS :(
    Object* operator-&gt;() { return m_object.get(); }
    Object* operator*()  { return *m_object; }
  private:
    ObjectHandle m_handle;
    <span class="hl-code-i">std::shared_ptr&lt;Object&gt; m_object;</span>
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Why does this work?</h3>
        <br/>
        <ul>
          <li class="fragment">We're not sure</li>
          <li class="fragment">Possibly accessing the use count within a mutex lock helps</li>
          <li class="fragment">... or some such</li>
        </ul>
      </section>

      <section class="slide">
        <h3>"Cool" Objects</h3>
        <br/>
        <ul>
          <li><span class="fancy">Optional CoW</span> only if we have active readers</li>
          <li><span class="fancy">Readers wait</span> on active writers by locking a mutex</li>
          <li>Synchronised writes from any thread</li>
          <li>We actually do use these in some places</li>
        </ul>
      </section>
      </section>

      <section class="slide">
        <h3>Improving Terminology</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject;
      std::mutex m_accessMutex;
      std::shared_ptr&lt;const Object&gt; <span class="fragment hl-code">read</span>() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; writeLock() {
          m_accessMutex.lock();
          m_writeObject = std::make_shared&lt;Object&gt;(*m_object);
          return m_writeObject;
      }
      void writeUnlock() {
          std::atomic_store_explicit(&amp;m_object, m_writeObject,
              std::memory_order_relaxed);
          m_accessMutex.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Improving Terminology</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject;
      std::mutex m_accessMutex;
      std::shared_ptr&lt;const Object&gt; <span class="hl-code-i">detach</span>() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; <span class="fragment hl-code persist">writeLock</span>() {
          m_accessMutex.lock();
          m_writeObject = std::make_shared&lt;Object&gt;(*m_object);
          return m_writeObject;
      }
      void <span class="fragment hl-code persist">writeUnlock()</span> {
          std::atomic_store_explicit(&amp;m_object, m_writeObject,
              std::memory_order_relaxed);
          m_accessMutex.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Improving Terminology</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject;
      std::mutex m_accessMutex;
      std::shared_ptr&lt;const Object&gt; detach() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; <span class="hl-code-i">beginTransaction()</span> {
          m_accessMutex.lock();
          m_writeObject = std::make_shared&lt;Object&gt;(*m_object);
          return m_writeObject;
      }
      void <span class="hl-code-i">endTransaction()</span> {
          std::atomic_store_explicit(&amp;m_object, m_writeObject,
              std::memory_order_relaxed);
          m_accessMutex.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Improving Terminology</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject;
      std::mutex <span class="hl-code-i">m_transactionMutex</span>;
      std::shared_ptr&lt;const Object&gt; detach() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; beginTransaction() {
          <span class="hl-code-i">m_transactionMutex</span>.lock();
          m_writeObject = std::make_shared&lt;Object&gt;(*m_object);
          return m_writeObject;
      }
      void endTransaction() {
          std::atomic_store_explicit(&amp;m_object, m_writeObject,
              std::memory_order_relaxed);
          <span class="hl-code-i">m_transactionMutex</span>.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Improving Terminology</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject;
      std::mutex m_transactionMutex;
      std::shared_ptr&lt;const Object&gt; detach() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; beginTransaction() {
          m_transactionMutex.lock();
          m_writeObject = std::make_shared&lt;Object&gt;(*m_object);
          return m_writeObject;
      }
      void endTransaction(<span class="hl-code-i">bool store</span>) {
          <span class="hl-code-i">if (store) {</span>
            std::atomic_store_explicit(&amp;m_object, m_writeObject,
                std::memory_order_relaxed);
          }
          m_transactionMutex.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Our Immutable Objects So Far</h3>
        <br/>
        <ul>
          <li><span class="fancy">Atomic transactions</span>: synchronised writes from any thread</li>
          <li><span class="fancy">Always CoW</span> on transaction</li>
          <li>Fastest possible <span class="fancy">lockless reads</span> by detaching</li>
          <li>A detached object is possibly outdated</li>
          <li>Every reference to the object is <span class="fancy">safe and valid forever</span></li>
          <li>Why, yes, this <em>can</em> be called a glorified <code class="cinline">shared_ptr</code> wrapper</li>
          <li>It requires <span class="fancy">a different way of thinking</span></li>
        </ul>
      </section>

      <section>
        <p>Indeed, at first we didn't think much of it</p>
      </section>

      <section>
        <p>Hmm... smells like <span class="fancy">React.js</span></p>
      </section>

      <section class="slide">
        <h3>React.js</h3>
        <br/>
        <ul>
          <li>It's a GUI library for single-page applications</li>
          <li>Take a state</li>
          <li>Create the DOM - the elements on the page</li>
          <li>That's it</li>
          <li>Let's see an example...</li>
        </ul>
      </section>

      <section class="slide">
        <h3>Imaging Session State</h3>
        <p>...in JavaScript</p>
        <pre><code class="javascript hljs" data-noescape>
  imagingState = {
    <span class="fragment hl-code">patient</span>: {
      orientation: null,
      weight: null,
    },
    <span class="fragment hl-code">image</span>: {
      name: '',
      notes: '',
      size: {x: 0, y: 0, z: 0},
      buffer: null,
      progress: 0,
    },
    <span class="fragment hl-code">table</span>: {
      pos: {x: 0, y: 0, z: 0},
      progress: 0,
    },
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Build Some GUI</h3>
        <pre><code class="javascript hljs" data-noescape>
  <span class="hl-code-i">buildGUI</span>({
    patient: {
      orientation: HeadFirstSuppine,
      weight: 80000,
    },
    image: {
      name: 'My Image',
      notes: 'Notes on my image',
      size: {x: 200, y: 200, z: 200},
      buffer: Loader.loadImage('test.img'),
      progress: 1,
    },
    table: {
      pos: {x: 2, y: 3, z: 4},
      progress: 0.5,
    },
  });
        </code></pre>
      </section>

      <!-- <section>
      </section> -->

      <section class="slide">
        <h3>Change the State</h3>
        <br/>
        <pre><code class="javascript hljs" data-noescape>
  function setImageName() {
    return { image: { name: "Cool image" }}};
  }
        </code></pre>
        <pre><code class="javascript hljs" data-noescape>
  function shiftTable(state) {
    return { table: { pos: { y: state.table.pos.y + 20 }}}};
  }
        </code></pre>
        <p class="pinner">Thanks to JS reflection. These will be spliced onto the state</p>
      </section>

      <section class="slide">
        <h3>Splicing onto the State</h3>
        <pre><code class="javascript hljs" data-noescape>  function setImageName() {
    return { image: { name: "Cool image" }}};
  }</code></pre>
        <pre><code class="ruby hljs" data-noescape>  state:
    patient:
      orientation: HeadFirstSuppine
      weight: 80000
    image:
      <span class="fragment red-code">name:</span> "My image"
      notes: "Notes on my image"
      size:
        x:200 y:200 z:200
      buffer: [0,3,132,34,12...
      progress: 1
    table:
      pos:
        x:2 y:3 z:4
      progress: 0.5
        </code></pre>
      </section>

      <section class="slide">
        <h3>Splicing onto the State</h3>
        <pre><code class="javascript hljs" data-noescape>  function setImageName() {
    return { image: { name: "Cool image" }}};
  }

  <span class="fragment hl-code">let oldState = state;</span>

  <span class="fragment hl-code">state = reactSplice(state, setImageName);</span>

  <span class="fragment hl-code">console.assert(state !== oldState, "Uh-oh");</span> <span class="fragment hl-code-i">// Uh-oh</span>
        </code></pre>

        <p style="text-align: right;"><em>Only the names have changed</em> - Jon Bon Jovi</p>
      </section>

      <section class="slide">
        <h3>Splicing onto the State</h3>
        <pre><code class="javascript hljs" data-noescape>  function setImageName() {
    return { image: { name: "Cool image" }}};
  }</code></pre>
        <pre><code class="ruby hljs" data-noescape>  <span class="fragment red-code">state:</span>
    patient:
      orientation: HeadFirstSuppine
      weight: 80000
    <span class="fragment red-code">image:</span>
      <span class="fragment red-code">name:</span> "My image"
      notes: "Notes on my image"
      size:
        x:200 y:200 z:200
      buffer: [0,3,132,34,12...
      progress: 1
    table:
      pos:
        x:2 y:3 z:4
      progress: 0.5
        </code></pre>
      </section>

      <section class="slide">
        <h3>Splicing onto the State</h3>
        <pre><code class="javascript hljs" data-noescape>  function setImageName() {
    return { image: { name: "Cool image" }}};
  }

  let oldState = state;

  state = reactSplice(state, setImageName);

  console.assert(state !== oldState, "Uh-oh"); <span class="fragment hl-code-i">// Everything is fine</span>
        </code></pre>
      </section>

      <section class="slide">
        <h3>Building GUI</h3>
        <br/>
        <pre><code class="javascript hljs" data-noescape>
    if (state != oldState) return null;
        </code></pre>
        <pre><code class="javascript hljs" data-noescape>
    if (state.image !== oldState.image) return null;
    return &lt;img src="...
        </code></pre>
      </section>

      <section>
        <p>React.js-style state in C++?</p>
        <p>That would be pretty cool!</p>
      </section>

      <section>
        <img src="but-why.gif" />
      </section>

      <section class="slide">
        <h3>Build GUI</h3>
        <br/>
        <pre><code class="cpp hljs" data-noescape>
    auto state = getState();
    buildGUI(state);
        </code></pre>
      </section>

      <section class="slide">
        <h3>Run Workers</h3>
        <br/>
        <pre><code class="cpp hljs" data-noescape>
    auto state = getState();
    findBladder(state-&gt;image);
    findFemurs(state-&gt;image);
    calculateElectronDensity(state-&gt;ctImage, state-&gt;structures["ptv"]);
        </code></pre>
      </section>

      <section class="slide">
        <h3>Undo &amp; Redo</h3>
        <br/>
        <pre><code class="cpp hljs" data-noescape>
    undoAction-&gt;old = getState()-&gt;structures["bladder"];
    applyManualUserEditsTo("bladder");
    undoAction-&gt;cur = getState()-&gt;structures["bladder"];
        </code></pre>
      </section>

      <section>
        <p>But most importantly...</p>
      </section>

      <section>
        <h2>Integration Testing by Unit Testing</h2>
      </section>

      <section class="slide">
        <h3>Here's a thought</h3>
        <pre><code class="cpp hljs" data-noescape>
    auto state = getState();
    buildGUI(state);
        </code></pre>
        <p>What if...</p>
        <pre><code class="cpp hljs" data-noescape>
    auto state = somePredefinedState();
    buildGUI(state);
    assert(currentGUI == expectedGUI);
        </code></pre>
        <p class="pinner">Then what if...</p>
      </section>

      <section>
        <pre><code class="cpp hljs" data-noescape>
    auto state = somePredefinedState();
    treatment(state, receivedNewImageFromMRI, loader.loadImage("test.img"));
    assert(deepCompare(getState(), expectedState));
        </code></pre>
        <p>Big Bang Integration Testing</p>
      </section>

      <section>
        <pre><code class="cpp hljs" data-noescape>
    auto state = somePredefinedState();
    <span class="hl-code-i">imaging</span>(state, receivedNewImageFromMRI, loader.loadImage("test.img"));
    assert(deepCompare(getState(), expectedState));
        </code></pre>
        <p>Bottom-Up Integration Testing</p>
      </section>

      <section>
        <pre><code class="cpp hljs" data-noescape>
    auto state = somePredefinedState();
    // Mock
    auto <span class="hl-code-i">imaging</span> = [](State& s){ if (!s.image) s.image=loader.loadImage("test.img");};
    <span class="fragment hl-code">treatment(state);</span>
    assert(deepCompare(getState(), expectedState));
        </code></pre>
        <p>Top-Down Integration Testing</p>
      </section>

      <section class="slide">
        <h3>Integration Testing by Unit Testing</h3>
        <br/>
        <ul>
          <li>When we have the app state in a <span class="fancy">single object</span>...</li>
          <li>...everything the application does is a <span class="fancy">pure function</span></li>
          <li><code class="cinline">State doSomething(const State&)</code></li>
          <li>...which can be unit tested</li>
        </ul>
      </section>

      <section class="slide">
        <h3>Moreover...</h3>
        <br/>
        <ul>
          <li>Since all modules are functions...</li>
          <li><span class="fancy">...mocks are trivial</span></li>
          <li>Since the entire state is an object...</li>
          <li><span class="fancy">...fuzzing is easy</span></li>
          <li>Since the an object can be saved to and loaded from disk...</li>
          <li><span class="fancy">...resuming after a crash is trivial</span></li>
          <li><span class="fancy">...jump in time debugging is possible</span></li>
        </ul>
      </section>

      <section>
        <p>That got us intrigued</p>
      </section>

      <section>
        <p>So... back to our objects...</p>
      </section>

      <section class="slide">
        <h3><code>shared_ptr</code> Wrapper and React.js</h3>
        <br/>
        <ul>
          <li><span class="fancy">Shallow compare</span>: <code class="cinline">a == b</code> compares addresses</li>
          <ul>
            <li>Not <code>string_view</code> anymore</li>
          </ul>
          <li>CoW on every change is like React splicing</li>
          <li>Detached references are <span class="fancy">safe and valid forever</span></li>
        </ul>
      </section>

      <section class="slide">
        <h3>Let's Build the State in C++</h3>
        <br/><br/>
        <p class="pinner">But first...</p>
      </section>

      <section class="slide">
        <h3>The Object</h3>
        <pre><code class="cpp hljs" data-noescape>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject;
      std::mutex m_transactionMutex;
      std::shared_ptr&lt;const Object&gt; detach() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; beginTransaction() {
          m_transactionMutex.lock();
          m_writeObject = std::make_shared&lt;Object&gt;(*m_object);
          return m_writeObject;
      }
      void endTransaction(bool store) {
          if (store) {
              std::atomic_store_explicit(&amp;m_object, m_writeObject,
                  std::memory_order_relaxed);
          }
          m_transactionMutex.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>More changes</h3>
        <pre><code class="cpp hljs" data-noescape>  <span class="hl-code-i">template &lt;typename T&gt;</span>
  class ObjectWrapper {
      std::shared_ptr&lt;Object&gt; m_object;
      std::shared_ptr&lt;Object&gt; m_writeObject;
      std::mutex m_transactionMutex;
      std::shared_ptr&lt;const Object&gt; detach() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;Object&gt; beginTransaction() {
          m_transactionMutex.lock();
          m_writeObject = std::make_shared&lt;Object&gt;(*m_object);
          return m_writeObject;
      }
      void endTransaction(bool store) {
          if (store) {
              std::atomic_store_explicit(&amp;m_object, m_writeObject,
                  std::memory_order_relaxed);
          }
          m_transactionMutex.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>More changes</h3>
        <pre><code class="cpp hljs" data-noescape>  template &lt;typename T&gt;
  class ObjectWrapper {
      std::shared_ptr&lt;<span class="hl-code-i">T</span>&gt; m_object;
      std::shared_ptr&lt;<span class="hl-code-i">T</span>&gt; m_writeObject;
      std::mutex m_transactionMutex;
      std::shared_ptr&lt;const <span class="hl-code-i">T</span>&gt; detach() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;<span class="hl-code-i">T</span>&gt; beginTransaction() {
          m_transactionMutex.lock();
          m_writeObject = std::make_shared&lt;T&gt;(*m_object);
          return m_writeObject;
      }
      void endTransaction(bool store) {
          if (store) {
              std::atomic_store_explicit(&amp;m_object, m_writeObject,
                  std::memory_order_relaxed);
          }
          m_transactionMutex.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>More changes</h3>
        <pre><code class="cpp hljs" data-noescape>  template &lt;typename T&gt;
  class <span class="hl-code-i">Object</span> {
      std::shared_ptr&lt;T&gt; m_object;
      std::shared_ptr&lt;T&gt; m_writeObject;
      std::mutex m_transactionMutex;
      std::shared_ptr&lt;const T&gt; detach() const {
          return std::atomic_load_explicit(&amp;m_object, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;T&gt; beginTransaction() {
          m_transactionMutex.lock();
          m_writeObject = std::make_shared&lt;T&gt;(*m_object);
          return m_writeObject;
      }
      void endTransaction(bool store) {
          if (store) {
              std::atomic_store_explicit(&amp;m_object, m_writeObject,
                  std::memory_order_relaxed);
          }
          m_transactionMutex.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>More changes</h3>
        <pre><code class="cpp hljs" data-noescape>  template &lt;typename T&gt;
  class Object {
      std::shared_ptr&lt;T&gt; <span class="hl-code-i">m_data</span>;
      std::shared_ptr&lt;T&gt; <span class="hl-code-i">m_transactionData</span>;
      std::mutex m_transactionMutex;
      std::shared_ptr&lt;const T&gt; detach() const {
          return std::atomic_load_explicit(&amp;<span class="hl-code-i">m_data</span>, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;T&gt; beginTransaction() {
          m_transactionMutex.lock();
          <span class="hl-code-i">m_transactionData</span> = std::make_shared&lt;T&gt;(*<span class="hl-code-i">m_data</span>);
          return <span class="hl-code-i">m_transactionData</span>;
      }
      void endTransaction(bool store) {
          if (store) {
              std::atomic_store_explicit(&amp;<span class="hl-code-i">m_data</span>, <span class="hl-code-i">m_transactionData</span>,
                  std::memory_order_relaxed);
          }
          m_transactionMutex.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>More Changes</h3>
        <pre><code class="cpp hljs" data-noescape>  template &lt;typename T&gt;
  class Transaction { // used to be WriteLock
  public:
      Transaction(Object&lt;T&gt;&amp; obj) : m_object(obj) {
          m_object.beginTransaction();
      }
      ~Transaction() {
          m_object.endTransaction(<span class="fragment hl-code">std::uncaught_exceptions() == 0</span>);
      }

      Object* operator-&gt;() { return m_object.m_transactionData.get(); }
      Object* operator*()  { return *m_object.m_transactionData; }
  private:
      Object&lt;T&gt;&amp; m_object;
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>So, Let's Build the State in C++</h3>
        <pre><code class="cpp hljs" data-noescape>  struct ImagingState {
<span class="fragment hl-code">      struct PatientData {
          Orientation orientation;
          grams weight;
      };
      PatientData patient;</span>
<span class="fragment hl-code">      struct ImageData {
          string name;
          string notes;
          point3 size;
          vector&lt;byte&gt; buffer;
          float progress = 0;
      };
      ImageData image;</span>
<span class="fragment hl-code">      struct TableData {
          point3 pos;
          float progress = 0;
      };
      TableData table;</span>
  };

  <span class="fragment hl-code">using ImagingStateObject = Object&lt;ImagingState&gt;;</span>
        </code></pre>
      </section>

      <section>
        <p>Obviously that's not enough</p>
        <p>We copy <span class="fancy">everything</span></p>
      </section>

      <section class="slide">
        <h3>More Objects?</h3>
        <pre><code class="cpp hljs" data-noescape>struct ImagingState {
      struct PatientData {
          Orientation orientation;
          grams weight;
      };
      <span class="hl-code-i">Object&lt;PatientData&gt;</span> patient;
      struct ImageData {
          string name;
          string notes;
          point3 size;
          vector&lt;byte&gt; buffer;
          float progress = 0;
      };
      <span class="hl-code-i">Object&lt;ImageData&gt;</span> image;
      struct TableData {
          point3 pos;
          float progress = 0;
      };
      <span class="hl-code-i">Object&lt;TableData&gt;</span> table;
  };

  using ImagingStateObject = Object&lt;ImagingState&gt;;
        </code></pre>
      </section>

      <section class="slide">
        <h3>All of the Objects?</h3>
        <pre><code class="cpp hljs" data-noescape>struct ImagingState {
      struct PatientData {
          <span class="hl-code-i">Object&lt;Orientation&gt;</span> orientation;
          <span class="hl-code-i">Object&lt;grams&gt;</span> weight;
      };
      <span class="hl-code-i">Object&lt;PatientData&gt;</span> patient;
      struct ImageData {
          <span class="hl-code-i">Object&lt;string&gt;</span> name;
          <span class="hl-code-i">Object&lt;string&gt;</span> notes;
          <span class="hl-code-i">Object&lt;point3&gt;</span> size;
          <span class="hl-code-i">Object&lt;vector&lt;byte&gt;&gt;</span> buffer;
          <span class="hl-code-i">Object&lt;float&gt;</span> progress = 0;
      };
      <span class="hl-code-i">Object&lt;ImageData&gt;</span> image;
      struct TableData {
          <span class="hl-code-i">Object&lt;point3&gt;</span> pos;
          <span class="hl-code-i">Object&lt;float&gt;</span> progress = 0;
      };
      <span class="hl-code-i">Object&lt;TableData&gt;</span> table;
  };

  using ImagingStateObject = Object&lt;ImagingState&gt;;
        </code></pre>
      </section>

      <section class="slide">
        <h3>Some Objects <span class="fragment">(It's hard)</span></h3>
        <pre><code class="cpp hljs" data-noescape>struct ImagingState {
      struct PatientData {
          Orientation</span> orientation;
          grams</span> weight;
      };
      <span class="hl-code-i">Object&lt;PatientData&gt;</span> patient;
      struct ImageData {
          <span class="hl-code-i">Object&lt;string&gt;</span> name;
          <span class="hl-code-i">Object&lt;string&gt;</span> notes;
          <span class="hl-code-i">Object&lt;point3&gt;</span> size;
          <span class="hl-code-i">Object&lt;vector&lt;byte&gt;&gt;</span> buffer;
          float</span> progress = 0;
      };
      <span class="hl-code-i">Object&lt;ImageData&gt;</span> image;
      struct TableData {
          <span class="hl-code-i">Object&lt;point3&gt;</span> pos;
          float</span> progress = 0;
      };
      <span class="hl-code-i">Object&lt;TableData&gt;</span> table;
  };

  using ImagingStateObject = Object&lt;ImagingState&gt;;
        </code></pre>
      </section>

      <section>
        <p>Ok. Let's try this...</p>
      </section>

      <section class="slide">
        <h3>Set Image Name</h3>
        <br/>
        <pre><code class="javascript hljs" data-noescape>
  function setImageName() {
    return { image: { name: "Cool image" }}};
  }
        </code></pre>
        <pre><code class="cpp hljs" data-noescape>
  *Transaction(Transaction(Transaction(state)-&gt;image)-&gt;name)) = "Cool image";
        </code></pre>
        <ul>
          <li>That's a lot of transactions, Batman</li>
          <li>That's a lot of recursive mutex locks, Batman</li>
          <li>And that's not the worst part</li>
        </ul>
      </section>

      <section class="slide">
        <h3>The Worst Part</h3>
        <br/>
        <pre><code class="cpp hljs" data-noescape>
  auto oldImage = state-&gt;detach()-&gt;image-&gt;detach();// That's a lot of detach(), Batman
  *Transaction(oldImage-&gt;name) = "something different";
  auto curImage = state-&gt;detach()-&gt;image-&gt;detach();
  assert(*oldImage-&gt;name-&gt;detach() != *curImage-&gt;name-&gt;detach());
  // Uh-oh, they both are "something different"
        </code></pre>
        <ul>
          <li>We "kinda" broke the <code class="cinline">detach</code> promise</li>
          <li>This is not the way of React.js</li>
        </ul>
      </section>

      <section class="slide">
        <h3>Split the Object</h3>
        <pre><code class="cpp hljs" data-noescape>  template &lt;typename T&gt;
  class <span class="hl-code-i">RootObject</span> {
      std::shared_ptr&lt;T&gt; m_data;
      std::shared_ptr&lt;T&gt; m_transactionData;
      std::mutex m_transactionMutex;
      std::shared_ptr&lt;const T&gt; detach() const {
          return std::atomic_load_explicit(&amp;m_data, std::memory_order_relaxed);
      }
      std::shared_ptr&lt;T&gt; beginTransaction() {
          m_transactionMutex.lock();
          m_transactionData = std::make_shared&lt;T&gt;(*m_data);
          return m_transactionData;
      }
      void endTransaction(bool store) {
          if (store) {
              std::atomic_store_explicit(m_data, m_transactionData,
                  std::memory_order_relaxed);
          }
          m_transactionMutex.unlock();
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Split the Object</h3>
        <pre><code class="cpp hljs" data-noescape>  template &lt;typename T&gt;
  class Node {
      std::shared_ptr&lt;T&gt; m_data;
      const T* operator-&gt;() const { return m_data.get(); }
      const T&amp; operator*() const { return *m_data; }
      T* operator-&gt;() {
          cow();
          return m_data.get();
      }
      T&amp; operator*() {
          cow();
          return *m_data;
      }
      void cow() { // moo
          m_data = std::make_shared&lt;T&gt;(*m_data); // no need for atomic
      }
      std::shared_ptr&lt;const T&gt; payload() const { return m_data; }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Imaging State</h3>
        <pre><code class="cpp hljs" data-noescape>struct ImagingState {
      struct PatientData {
          Orientation</span> orientation;
          grams</span> weight;
      };
      <span class="hl-code-i">Node&lt;PatientData&gt;</span> patient;
      struct ImageData {
          <span class="hl-code-i">Node&lt;string&gt;</span> name;
          <span class="hl-code-i">Node&lt;string&gt;</span> notes;
          <span class="hl-code-i">Node&lt;point3&gt;</span> size;
          <span class="hl-code-i">Node&lt;vector&lt;byte&gt;&gt;</span> buffer;
          float</span> progress = 0;
      };
      <span class="hl-code-i">Node&lt;ImageData&gt;</span> image;
      struct TableData {
          <span class="hl-code-i">Node&lt;point3&gt;</span> pos;
          float</span> progress = 0;
      };
      <span class="hl-code-i">Node&lt;TableData&gt;</span> table;
  };

  using ImagingStateObject = <span class="fragment hl-code">RootObject</span>&lt;ImagingState&gt;;
        </code></pre>
      </section>

      <section class="slide">
        <h3>Set Image Name</h3>
        <br/>
        <pre><code class="javascript hljs" data-noescape>
  function setImageName() {
    return { image: { name: "Cool image" }}};
  }
        </code></pre>
        <pre><code class="cpp hljs" data-noescape>
  *Transaction(state)-&gt;image-&gt;name = "Cool image";
        </code></pre>
        <p class="pinner">Shallow copy-on-write on state-image-name</p>
      </section>

      <section class="slide">
        <h3>Test</h3>
        <pre><code class="cpp hljs" data-noescape>
  auto oldState = state.detach();
  auto name = oldState-&gt;image-&gt;name.payload();
  *Transaction(state)-&gt;image-&gt;name = "something different";
  auto curState = state.detach();
  assert(oldState != curState); // shallow compare
  assert(oldState-&gt;image != curState-&gt;image); // shallow compare
  assert(oldState-&gt;image-&gt;name != curState-&gt;image-&gt;name); // shallow compare
  assert(*oldState-&gt;image-&gt;name != *curState-&gt;image-&gt;name); // string compare

        </code></pre>
        <p class="pinner">This is the React.js way</p>
      </section>

      <section class="slide">
        <h3>Problems</h3>
        <pre><code class="cpp hljs" data-noescape>
  *Transaction(state)-&gt;image-&gt;name = "Cool name";
  // we copied the old name, only to replace it with "Cool name"
        </code></pre>
        <pre><code class="cpp hljs" data-noescape>
  Transaction t(state);
  t-&gt;image-&gt;name = "foo";
  t-&gt;image-&gt;notes = "bar";
  // image gets CoW'd twice
        </code></pre>
        <pre><code class="cpp hljs" data-noescape>
  Transaction t(state);
  if (t->image->buffer->empty()) {
      t-&gt;image-&gt;name = "&lt;empty&gt;";
  }
  // we copy-on-write even if we change nothing
        </code></pre>
      </section>

      <section>
        <section>
          <img class="diagram" src="kuzco.png" alt="kuzco" />
          <h2>Kuzco</h2>
          <p><a href="https://github.com/iboB/kuzco">gh/iboB/kuzco</a></p>
        </section>
        <section>
          <p>TBD</p>
        </section>
      </section>

      <section class="slide">
        <h3>Kuzco Solutions</h3>
        <pre><code class="cpp hljs" data-noescape>
  *Transaction(state)-&gt;image-&gt;name = "Cool name";
  <span class="fragment">// no copies of name</span>
        </code></pre>
        <pre><code class="cpp hljs" data-noescape>
  Transaction t(state);
  t-&gt;image-&gt;name = "foo";
  t-&gt;image-&gt;notes = "bar";
  <span class="fragment">// image gets CoW'd once</span>
        </code></pre>
        <pre><code class="cpp hljs" data-noescape>
  Transaction t(state);
  if (t<span class="fragment hl-code persist">.r()</span>->image->buffer->empty()) {
      t-&gt;image-&gt;name = "&lt;empty&gt;";
  }
  <span class="fragment">// no copies if we don't change</span>
        </code></pre>
      </section>

      <section class="slide">
        <h3>More Problems</h3>
        <pre><code class="cpp hljs" data-noescape>  struct MRIStudy {
      std::vector&lt;Image&gt; images;
      // ...
  };
  // copy vector on every change?</code></pre>
        <pre><code class="cpp hljs" data-noescape>  struct MRIStudy {
      Node&lt;std::vector&lt;Image&gt;&gt; images;
      // ...
  };
  // copy all images on every change?</code></pre>
        <pre><code class="cpp hljs" data-noescape>  struct MRIStudy {
      Node&lt;std::vector&lt;Node&lt;Image&gt;&gt;&gt; images;
      // ...
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>More Problems</h3>
        <pre><code class="cpp hljs" data-noescape>
  Transaction(state)->images->emplace_back();
        </code></pre>
        <p>What happens here?</p>
        <ol>
          <li>Copy <code class="cinline">state</code>. Fine</li>
          <li>Copy <code class="cinline">images</code>. Er... fine</li>
          <li><code class="cinline">emplace_back</code> needs to reallocate. Ew... fine</li>
          <li>Copy <code class="cinline">images</code>. <span class="fancy">This is were I draw the line!</span></li>
        </ol>
      </section>

      <section class="slide">
        <h3>Custom Container Wrappers</h3>
        <pre><code class="cpp hljs" data-noescape>
  template &lt;typename T&gt;
  class NodeVector {
      std::shared_ptr&lt;std::vector&lt;T&gt;&gt; m_data;
      auto& emplace_back() {
          auto old = m_data;
          m_data = std::make_shared&lt;std::vector&lt;T&gt;&gt;();
          m_data.reserve(old.size());
          m_data = old;
          return m_data.emplace_back();
      }
      // ...
  };
        </code></pre>
        <p class="pinner">The same for other containers</p>
      </section>

      <section class="slide">
        <h3>That's a Lot of Allocations, Batman</h3>
        <pre><code class="cpp hljs" data-noescape>  // 4 allocs here multiple times per second
  Transaction(state)-&gt;imaging-&gt;image[0]-&gt;progress-&gt;value = 0.4f;</code></pre>
        <br/>
        <ul>
          <li>So far we haven't done anything about it</li>
          <li>Better state structure?</li>
          <li>Custom allocators?</li>
          <li>Reimplementing <code class="cinline">std::shared_ptr</code>?</li>
          <li>Do we even need weak pointers?</li>
          <li>Still gathering information</li>
        </ul>
      </section>

      <section class="slide">
        <h3>That's a Lot of Copying</h3>
        <p style="text-align: right;">... Batman</p>
        <ul>
          <li>Imagine <code class="cinline">setImageVoxel(point3, value)</code></li>
          <li>Copy <span class="fancy">tens of megabytes</span> of an image?</li>
          <li><span class="fancy">This is a real limitation</span></li>
          <li>We just don't do that</li>
          <li>A mutable placeholder with conventional locks?</li>
          <li>Manual contouring works like this</li>
          <li>If this is everything to do, perhaps <span class="fancy">that's not the right pattern</span></li>
        </ul>
      </section>

      <section class="slide">
        <h3>Reuse</h3>
        <pre><code class="cpp hljs" data-noescape>
  bool shouldTakeScan(const State& state) {
      return state.image-&gt;empty() || *state.image->retake;
  }
        </code></pre>
        <pre><code class="cpp hljs" data-noescape>
  struct Imaging { Node&lt;Image&gt; image; };
  struct Treatment { Node&lt;Imaging&gt; imaging; };
  struct Diagnosis { Node&lt;Imaging&gt; phase1; }
        </code></pre>
        <p class="pinner">How can we reuse <code class="cinline">shouldTakeScan</code>?</p>
      </section>

      <section class="slide">
        <h3>Queries</h3>
        <pre><code class="cpp hljs" data-noescape>
  bool shouldTakeScan(const State&amp; state) {
      auto image = query&lt;GetImaging&gt;(state)-&gt;image;
      return image-&gt;empty() || *image->retake;
  }</code></pre>
        <pre><code class="cpp hljs" data-noescape>  // Chaining
  bool shouldTakeScan(const State&amp; state) {
      auto image = query&lt;GetImaging&gt;(state).q&lt;GetImage&gt;();
      return image-&gt;empty() || *image->retake;
  }</code></pre>
        <pre><code class="cpp hljs" data-noescape>  // Mutable
  void calculateBladder(Transaction&lt;State&gt;&amp; state) {
      auto b = query&lt;GetOrgans&gt;(state).q&lt;GetOrgan&gt;("bladder");
      b = calcBladder(query&lt;GetImaging&gt;(state.r()).q&lt;GetImage&gt;());
  }
        </code></pre>
      </section>

      <section class="slide">
        <h3>React.js-Style Objects in C++</h3>
        <br/>
        <ul>
          <li><span class="fancy">Immutable objects</span> based on ref-counted pointers</li>
          <li>Shallow copies</li>
          <li>Shallow compares</li>
          <li><span class="fancy">State composed of nodes</span></li>
          <li>Special nodes for containers</li>
          <li>Queries</li>
          <li>Not always the way to go :(</li>
          <li><span class="fancy">Mucho potential</span></li>
        </ul>
      </section>

      <section>
        <h3>End of Part 1</h3>
      </section>

      <section>
        <h3>Part 2</h3>
        <h2>How do We Use Them?</h2>
      </section>

      <section class="slide">
        <h3>Actions</h3>
        <br/>
        <ul>
          <li>Since we're implementing React, why not implement Redux?</li>
          <li>An action changes the state</li>
          <li>"Set name of scan N in the study": N and name</li>
          <li>"Receive new delivery frame": Image, dose, confidence...</li>
          <li>"Set the entire state to this"</li>
        </ul>
      </section>

      <section class="slide">
        <h3>Actions</h3>
        <pre><code class="cpp hljs" data-noescape>
  class SetNameOfScan {
    int n = 0;
    std::string name;

    template &lt;typename State&gt;
    void operator()(State&amp; state) {
        auto imaging = query&lt;GetImaging&gt;(state); // may throw "No imaging"
        if (canSetNameOfScan(imaging, n)) {
            imaging-&gt;images[n]-&gt;name = name;
        }
        else {
            throw BadAction(action);
        }
    }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Applying Actions</h3>
        <pre><code class="cpp hljs" data-noescape>
  template &lt;typename Action, typename State&gt;
  void applyAction(Action&amp; action, RootObject&lt;State&gt;&amp; state) {
      try {
          auto t = Transaction(state);
          action(*t);
      }
      catch (Exception&amp; e) {
          // most likely notify user that their action is invalid
          // or add fatal error to state (long story)
      }
  }
        </code></pre>

        <p class="pinner">Can a valid action lead to an invalid state invariant?</p>
        <p class="pinner">What if we want to enforce unique names?</p>
      </section>

      <section class="slide">
        <h3>Actions</h3>
        <pre><code class="cpp hljs" data-noescape>class SetNameOfScan {
    int n = 0;
    std::string name;

    template &lt;typename State&gt;
    void operator()(State&amp; state) {
        auto imaging = query&lt;GetImaging&gt;(state); // may throw "No imaging"
        if (canSetNameOfScan(imaging, n<span class="hl-code-i">, name</span>)) {
            imaging-&gt;images[n]-&gt;name = name;
        }
        else {
            throw BadAction(action);
        }
    }
  };</code></pre>
        <p class="pinner">No way to check validity of state unless we set the name</p>
        <p class="pinner">No way to validate <code class="cinline">SetEntireState</code></p>
      </section>

      <section class="slide">
        <h3>State Guards</h3>
        <pre><code class="cpp hljs" data-noescape>
  void checkValidImageNames(const Imaging&amp; img) {
      if (!allNamesUnique(img.images)) {
          throw BadState();
      }
  }</code></pre>
        <pre><code class="cpp hljs" data-noescape>  template &lt;typename State&gt;
  void checkValidImaging(const State&amp; state) {
      auto imaging = query&lt;GetImaging&gt;(state);
      checkValidImageNames(imaging);
      checkAllImagesOfSameSize(imaging);
      checkNoSimultaneousTableMoveAndScan(imaging);
      // ...
  }</code></pre>
      </section>

      <section class="slide">
        <h3>App</h3>
        <pre><code class="cpp hljs" data-noescape>  template &lt;typename State&gt;
  class App {
      RootObject&lt;State&gt; state;
      std::vector&lt;std::function&lt;void(const State&amp;)&gt;&gt; guards;
      void runGuards(const State&amp;);
  };
        </code></pre>
        Or...
        <pre><code class="cpp hljs" data-noescape>  class TreatmentApp {
      RootObject&lt;TreatmentState&gt; state;
      void runGuards(const State&amp; state) {
          checkPatient(state);
          checkImaging(state);
          checkDelivery(state);
      }
  };
        </code></pre>
      </section>

      <section class="slide">
        <h3>Applying Actions</h3>
        <pre><code class="cpp hljs" data-noescape>
  template &lt;typename Action, typename App&gt;
  void applyAction(Action&amp; action, <span class="hl-code-i">App&amp; app</span>) {
      try {
          auto t = Transaction(<span class="hl-code-i">app</span>.state);
          action(*t);
          <span class="hl-code-i">app.runGuards(*t);</span>
      }
      catch (Exception&amp; e) {
          // most likely notify user that their action is invalid
          // or add fatal error to state (long story)
      }
  }
        </code></pre>
      </section>

      <section>
        <img class="diagram" src="bnr.jpg" alt="Batman and Robin" />
        <p>That's a lot of guard calls</p>

      </section>

      <section class="slide">
        <h3>Optimizing Guard Calls</h3>
        <pre><code class="cpp hljs" data-noescape>
  struct CheckImaging {
    <span class="fragment hl-code persist">std::shared_ptr&lt;const Imaging&gt; lastValidatedImaging;</span>
    template &lt;typename State&gt;
    void operator()(const State&amp; state) {
        <span class="fragment hl-code persist">auto imaging = query&lt;GetImaging&gt;(state);</span>
        if (lastValidatedImaging == imaging) return;
        checkValidImageNames(imaging);
        checkAllImagesOfSameSize(imaging);
        checkNoSimultaneousTableMoveAndScan(imaging);
        // ...
        <span class="fragment hl-code persist">lastValidatedImaging = imaging;</span>
    }
  };
        </code></pre>
        <p class="pinner">Guards are <span class="fancy">not pure anymore</span> :(</p>
        <p class="pinner">Promising results on memoizing guards and queries on the state</p>
      </section>

      <section class="slide">
        <h3>PubSub</h3>
        <pre><code class="cpp hljs" data-noescape>
    void endTransaction(bool store) {
        <span class="fragment hl-code persist">std::shared_ptr&lt;const T&gt; newData</span>;
        if (store) {
            std::atomic_store_explicit(m_data, m_transactionData,
                std::memory_order_relaxed);
            <span class="fragment hl-code persist">newData = std::move(m_transactionData);</span>
        }
        m_transactionMutex.unlock();
<span class="fragment hl-code persist">        if (newData) {
            notifySubscribers(newData);
        }</span>
    }
        </code></pre>
        <p class="pinner">Notify on each state change, but not while locked</p>
      </section>

      <section class="slide">
        <h3>UI Example</h3>
        <pre><code class="cpp hljs" data-noescape>
  treatmentState.subscribe([uiThread] {
      guiThread.wakeUp();
  });
  // ...
  void UIThread::run() {
      waitUntilWokenUp();
      buildGUI(treatmentState.detach()); // ok if we skip states
  }
  // ...
  void UIThread::onSetImageName(UserPtr user, int i, std::string name) {
      treatmentSession.pushAction&lt;SetImageName&gt;(user, i, name);
  }

  void UIThread::onCalculateBladder(UserPtr user) {
      // ???
  }
        </code></pre>
      </section>

      <section>
        <h2>Multi-Threaded Stuff</h2>
      </section>

      <section class="slide">
        <h3>The User's Perspective</h3>
        <pre><code class="cpp hljs" data-noescape>
  void UserThread::run() {
      waitUntilWokenUp();
      std::future&lt;std::optional&lt;Action&gt;&gt; f
          = makeDecision(myBrainState, observedAppState);
      f.wait();
      auto action = f.get();
      if (action) app.pushAction(*action);
  }
        </code></pre>
        <p class="pinner">We translate declarative to imperative code</p>
      </section>

      <section class="slide">
        <h3>State Observers</h3>
        <pre><code class="cpp hljs" data-noescape>
  void bladderObserver() {  // delcarative code, to imperative code
      if (bladderCalculation.running()) {
          if (query&lt;GetImage&gt;(appState) != query&lt;GetImage&gt;(myState)) {
              bladderCalculation.abort();
          }
          else {
              return;
          }
      }
      if (!query&lt;GetBladder&gt;(appState)) {
          bladderCalculation.start();
          return;
      }
      if (query&lt;GetBladder&gt;(appState)->manualCalcRequested) {
          bladderCalculation.start();
          return;
      }
  }
        </code></pre>
      </section>

      <section class="slide">
        <h3>So This Means...</h3>
        <br/>
        <ul>
          <li><span class="fancy">Managed workers</span>. One does not simply <code class="cinline">std::thread t(func);</code></li>
          <li>Workers can named, found, started, aborted</li>
          <li>This means they <span class="fancy">can be single-threaded</span></li>
          <li>What to do with their result?</li>
          <li>Don't just post an action and abort, or risk rerun</li>
          <li>Post an action and wait until the result is collected!</li>
        </ul>
      </section>

      <section class="slide">
        <h3>Applying Async Results</h3>
        <pre><code class="cpp hljs" data-noescape>
  class SetBladder {
      void operator(State&amp; s) {
          auto worker = workers("Bladder");
          if (!worker-&gt;hasResult()) throw BadAction("no bladder");
          auto result = worker-&gt;collectResult();
          // only now is the bladder worker complete
          if (query&lt;GetImage&gt;(state.r()) != result.image {
              throw BadAction("outdated bladder");
          }
          query&lt;GetBladder&gt;(state) = result.bladder;
      }
  }
        </code></pre>
      </section>

      <section class="slide">
        <h3>State Observers</h3>
        <br/>
        <ul>
          <li>Run after every state change</li>
          <li>Manage workers based on their internal state</li>
          <li>Can also decide to synchronously push actions</li>
          <li>That's how Services communicate</li>
        </ul>
      </section>

      <section>
        <h2>Examples of Tests</h2>
      </section>

      <section class="slide">
        <h3>GUI</h3>
        <pre><code class="cpp hljs" data-noescape>
  auto state = load&lt;TreatmentState&gt;("treatment-delivery-beam-on.state");
  auto gui = generateGui(state);
  auto expectedGUI = load&lt;GUI&gt;("treatment-delivery-beam-on.gui");
  assert(gui == expectedGUI);
        </code></pre>
      </section>

      <section class="slide">
        <h3>Treatment</h3>
        <pre><code class="cpp hljs" data-noescape>
  auto patient = load&lt;Patient&gt;("john-doe.patient");
  auto app = newTreatment(patient);

  WorkerManager::setThreads(0);
  WorkerManager::overrideWorker("takeImage", []() {
      return load&lt;Image&gt;("test.img"); // mock
  });

  WorkerManager::exaustWorkers(); // synchronous

  assert(hasAllImages(app.state)); // auto imaging worked
  assert(hasAllOrgans(app.state)); // auto contouring worked
        </code></pre>
      </section>

      <section class="slide">
        <h3>Programming with Immutable Objects</h3>
        <br/>
        <ul>
          <li>Not a solution for every problem</li>
          <li>Programming and design is <span class="fancy">hard</span></li>
          <li>It can be <span class="fancy">overly verbose</span></li>
          <li>The performance is not great, not terrible</li>
          <li>Awesome testing and debugging power</li>
          <li>Unprecedented robustness</li>
        </ul>
      </section>

      <section>
        <h1>End</h1>
        <h2>Questions?</h2>
        <p>Borislav Stanimirov / <a href="https://ibob.github.io">ibob.github.io</a> / <a href="https://twitter.com/stanimirovb">@stanimirovb</a></p>
        <p>
          <small>
          These slides: <a href="https://ibob.github.io/slides/immutable-obj/">ibob.github.io/slides/immutable-obj/</a>
          </small>
          <br />
          <small>
          Slides license <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons By 4.0</a><br /><a rel="license" href="https://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
          </small>
        </p>
      </section>

    </div>
  </div>

  <script src="../lib/reveal.js-3.8.0/js/reveal.min.js"></script>
  <script src="../lib/slides.js"></script>

  <script>
    Reveal.initialize({
      width: 1280,
      height: 720,

      controls: true,
      progress: true,
      history: true,
      center: true,

      transition: 'none', // none/fade/slide/convex/concave/zoom

      autoPlayMedia: false,
      preloadIframes: false,

      // Optional libraries used to extend on reveal.js
      dependencies: [
        //{ src: 'markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        //{ src: 'markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'highlight/highlight.min.js', async: true, callback: function() {
          hljs.initHighlightingOnLoad();
        } },
        //{ src: 'zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
        //{ src: 'notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
      ].map(p => { p.src = '../lib/reveal.js-3.8.0/plugin/' + p.src; return p; })
    });

    slides.footerSetup('is.gd/immutable', 'CppCon 2020');
  </script>

</body>
</html>
